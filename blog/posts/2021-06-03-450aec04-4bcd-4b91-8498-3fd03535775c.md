---
title: django rest framework serializers小結 - 台部落
subtitle: 文章暂存
author: systemime
date: 2021-06-03
header_img: /img/in-post/header/11.jpg
catalog: true
tags:
  - python
---
摘要.

<!-- more -->
### 引言

　　serializers 是什麼？官網是這樣的”Serializers allow complex data such as querysets and model instances to be converted to native Python datatypes that can then be easily rendered into JSON, XML or other content types. “翻譯出來就是，將複雜的數據結構變成 json 或者 xml 這個格式的。  

　　在最近的學習中，個人看法，serializers 有以下幾個作用：  
　　 - 將 queryset 與 model 實例等進行序列化，轉化成 json 格式，返回給用戶 (api 接口)。  
　　- 將 post 與 patch/put 的上來的數據進行驗證。  
　　 - 對 post 與 patch/put 數據進行處理。  
　（後面的內容，將用 patch 表示 put/patch 更新，博主認爲 patch 更貼近更新的說法）  
　　簡單來說，針對 get 來說，serializers 的作用體現在第一條，但如果是其他請求，serializers 能夠發揮 2,3 條的作用！

　\*\*本文比較長，用張圖簡單介紹一下主要內容\*\*

![](https://pic1.xuehuaimg.com/proxy/csdn/https://img-blog.csdn.net/20180124215418027?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbF92aXA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### serializers.fieild

　　我們知道在 django 中，form 也有許多 field，那 serializers 其實也是 drf 中發揮着這樣的功能。我們先簡單瞭解常用的幾個 field。

#### 1. 常用的 field

　　CharField、BooleanField、IntegerField、DateTimeField 這幾個用得比較多，我們把外鍵的 field 放到後面去說！

````null

mobile = serializers.CharField(max_length=11, min_length=11)
age = serializers.IntegerField(min_value=1, max_value=100)

pay_time = serializers.DateTimeField(read_only=True,format='%Y-%m-%d %H:%M')
is_hot = serializers.BooleanField()```

*     
    

　　不同的是，我們在django中，form更強調對提交的表單進行一種驗證，而serializer的field不僅在進行數據驗證時起着至關重要的作用，在將數據進行序列化後返回也發揮着重要作用！！   
　　我們可以看出，不同的field可以用不同的關鍵參數，除此之外，還有一些十分重要有用的參數。

#### 2\. Core arguments參數

read\_only：True表示不允許用戶自己上傳，只能用於api的輸出。如果某個字段設置了read\_only=True，那麼就不需要進行數據驗證，只會在返回時，將這個字段序列化後返回   
　　舉個簡單的例子：在用戶進行購物的時候，用戶post訂單時，肯定會產生一個訂單號，而這個訂單號應該由後臺邏輯完成，而不應該由用戶post過來，如果不設置read\_only=True，那麼驗證的時候就會報錯。

```null
order_sn = serializers.CharField(readonly=True)```

*     
    

write\_only: 與read\_only對應   
required: 顧名思義，就是這個字段是否必填。   
allow\_null/allow\_blank：是否允許爲NULL/空 。   
error\_messages：出錯時，信息提示。

```null
name = serializers.CharField(required=True, min_length=6,
                error_messages={
                    'min_length': '名字不能小於6個字符',
                    'required': '請填寫名字'})
````

-

label: 字段顯示設置，如 label=’驗證碼’   
help_text: 在指定字段增加一些提示文字，這兩個字段作用於 api 頁面比較有用   
style: 說明字段的類型，這樣看可能比較抽象，看下面例子：

````null

password = serializers.CharField(
    style={'input_type': 'password'})

color_channel = serializers.ChoiceField(
    choices=['red', 'green', 'blue'],
    style={'base_template': 'radio.html'})```

*     
    

　　這裏面，還有一個十分有用的validators參數，這個我們會在後面提及！   
　　

#### 3\. HiddenField

　　HiddenField的值不依靠輸入，而需要設置默認的值，不需要用戶自己post數據過來，也不會顯式返回給用戶，最常用的就是user!!   
　　我們在登錄情況下，進行一些操作，假設一個用戶去收藏了某一門課，那麼後臺應該自動識別這個用戶，然後用戶只需要將課程的id post過來，那麼這樣的功能，我們配合CurrentUserDefault()實現。

```null
# 這樣就可以直接獲取到當前用戶
user = serializers.HiddenField(
    default=serializers.CurrentUserDefault())```

*     
    

### save instance

　　這個標題是官方文檔的一個小標題，我覺得用的很好，一眼看出，這是爲post和patch所設置的，沒錯，這一部分功能是專門爲這兩種請求所設計的，如果只是簡單的get請求，那麼在設置了前面的field可能就能夠滿足這個需求。   
　　我們在[view](http://blog.csdn.net/l_vip/article/details/79131289)以及[mixins](http://blog.csdn.net/l_vip/article/details/79142105)的博客中提及到，post請求對應create方法，而patch請求對應update方法，這裏提到的create方法與update方法，是指mixins中特定類中的方法。我們看一下源代碼，源代碼具體分析可以看到另外一篇博客[mixins](http://blog.csdn.net/l_vip/article/details/79142105)：

```null

class CreateModelMixin(object):
    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)

    def perform_create(self, serializer):
        serializer.save()

class UpdateModelMixin(object):
    def update(self, request, *args, **kwargs):
        partial = kwargs.pop('partial', False)
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=request.data, partial=partial)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)

        if getattr(instance, '_prefetched_objects_cache', None):
            
            
            instance._prefetched_objects_cache = {}

        return Response(serializer.data)

    def perform_update(self, serializer):
        serializer.save()```

*     
    

　　可以看出，無論是create與update都寫了一行：serializer.save( )，那麼，這一行，到底做了什麼事情，分析一下源碼。

```null

def save(self, **kwargs):

    ···
    if self.instance is not None:
        self.instance = self.update(self.instance, validated_data)
            ···
    else:
        self.instance = self.create(validated_data)
            ···
    return self.instance```

*     
    

　　顯然，serializer.save的操作，它去調用了serializer的create或update方法，不是mixins中的！！！我們看一下流程圖（以post爲例）

　　講了那麼多，我們到底需要幹什麼！重載這兩個方法！！   
　　如果你的viewset含有post，那麼你需要重載create方法，如果含有patch，那麼就需要重載update方法。

```null

class ArticleSerializer(serializers.Serializer):
    user = serializers.HiddenField(
        default=serializers.CurrentUserDefault())
    name = serializers.CharField(max_length=20)
    content = serializers.CharField()

    def create(self, validated_data):
    
    
        user = self.context['request'].user
        name = validated_data['name ']
        content = validated_data['content ']
        return Article.objects.create(**validated_data)

    def update(self, instance, validated_data):
    
        instance.name = validated_data.get('name')
        instance.content = validated_data.get('content')
        instance.save()
        return instance```

*     
    
*     
    

　　可能會有人好奇，系統是怎麼知道，我們需要調用serializer的create方法，還是update方法，我們從save( )方法可以看出，判斷的依據是：

```null
if self.instance is not None:pass```

*     
    

　　那麼我們的mixins的create與update也已經在爲開發者設置好了，

```null
# CreateModelMixin
serializer = self.get_serializer(data=request.data)
# UpdateModelMixin
serializer = self.get_serializer(instance, data=request.data, partial=partial)```

*     
    

　　也就是說，在update通過get\_object( )的方法獲取到了instance，然後傳遞給serializer，serializer再根據是否有傳遞instance來判斷來調用哪個方法！

### Validation自定義驗證邏輯

#### 單獨的validate

　　我們在上面提到field，它能起到一定的驗證作用，但很明顯，它存在很大的侷限性，舉個簡單的例子，我們要判斷我們手機號碼，如果使用CharField(max\_length=11, min\_length=11），它只能確保我們輸入的是11個字符，那麼我們需要自定義！

```null
mobile_phone = serializers.CharField(max_length=11, min_length=11）

def validate_mobile_phone(self, mobile_phone):
    
    
    if not re.match(REGEX_MOBILE, mobile):
    
        raise serializers.ValidationError("手機號碼非法")
    return mobile_phone```

*     
    

　　當然，這裏面還可以加入很多邏輯，例如，還可以判斷手機是否原本就存在數據庫等等。

#### 聯合validate

　　上面驗證方式，只能驗證一個字段，如果是兩個字段聯合在一起進行驗證，那麼我們就可以重載validate( )方法。

```null
    start = serializers.DateTimeField()
    finish = serializers.DateTimeField()

    def validate(self, attrs):
    
        if data['start'] > data['finish']:
            raise serializers.ValidationError("finish must occur after start")
        return attrs```

*     
    

　　這個方法非常的有用，我們還可以再這裏對一些read\_only的字段進行操作，我們在read\_only提及到一個例子，訂單號的生成，我們可以在這步生成一個訂單號，然後添加到attrs這個字典中。

```null
order_sn = serializers.CharField(readonly=True)
def validate(self, attrs):
    
    attrs['order_sn'] = generate_order_sn()
    return attrs```

*     
    

　　這個方法運用在modelserializer中，可以剔除掉write\_only的字段，這個字段只驗證，但不存在與指定的model當中，即不能save( )，可以在這delete掉！

#### Validators

validators可以直接作用於某個字段，這個時候，它與單獨的validate作用差不多

```null
def multiple_of_ten(value):
    if value % 10 != 0:
        raise serializers.ValidationError('Not a multiple of ten')

class GameRecord(serializers.Serializer):
    score = IntegerField(validators=[multiple_of_ten])```

*     
    

　　當然，drf提供的validators還有很好的功能：UniqueValidator，UniqueTogetherValidator等   
　　UniqueValidator: 指定某一個對象是唯一的，如，用戶名只能存在唯一：

```null
username = serializers.CharField(
        max_length=11, 
        min_length=11,
        validators=[UniqueValidator(queryset=UserProfile.objects.all())
    ）```

*     
    

　　UniqueTogetherValidator: 聯合唯一，如用戶收藏某個課程，這個時候就不能單獨作用於某個字段，我們在Meta中設置。

```null
    class Meta:
        validators = [
            UniqueTogetherValidator(
                queryset=UserFav.objects.all(),
                fields=('user', 'course'),
                message='已經收藏'
            )]```

*     
    

### ModelSerializer

　　講了很多Serializer的，在這個時候，我還是強烈建議使用ModelSerializer，因爲在大多數情況下，我們都是基於model字段去開發。

#### 好處：

　　ModelSerializer已經重載了create與update方法，它能夠滿足將post或patch上來的數據進行進行直接地創建與更新，除非有額外需求，那麼就可以重載create與update方法。   
　　ModelSerializer在Meta中設置fields字段，系統會自動進行映射，省去每個字段再寫一個field。

```null
class UserDetailSerializer(serializers.ModelSerializer):
    """
    用戶詳情序列化
    """

    class Meta:
        model = User
        fields = ("name", "gender", "birthday", "email", "mobile")
        
        
        ```

*     
    

#### ModelSerializer需要解決的2個問題：

　　1，某個字段不屬於指定model，它是write\_only，需要用戶傳進來，但我們不能對它進行save( )，因爲ModelSerializer是基於Model，這個字段在Model中沒有對應，這個時候，我們需要重載validate！   
如在用戶註冊時，我們需要填寫驗證碼，這個驗證碼只需要驗證，不需要保存到用戶這個Model中：

```null
    def validate(self, attrs):
        del attrs["code"]
        return attrs```

*     
    

　　2，某個字段不屬於指定model，它是read\_only，只需要將它序列化傳遞給用戶，但是在這個model中，沒有這個字段！我們需要用到SerializerMethodField。   
　　假設需要返回用戶加入這個網站多久了，不可能維持這樣加入的天數這樣一個數據，一般會記錄用戶加入的時間點，然後當用戶獲取這個數據，我們再計算返回給它。

```null
class UserSerializer(serializers.ModelSerializer):  
    days_since_joined = serializers.SerializerMethodField()
    
    def get_days_since_joined(self, obj):
    
        return (now() - obj.date_joined).days

    class Meta:
        model = User```

*     
    

　　當然，這個的SerializerMethodField用法還相對簡單一點，後面還會有比較複雜的情況。

### 關於外鍵的serializers

　　講了那麼多，終於要研究一下外鍵啦~   
　　其實，外鍵的field也比較簡單，如果我們直接使用serializers.Serializer，那麼直接用PrimaryKeyRelatedField就解決了。   
　　假設現在有一門課python入門教學(course)，它的類別是python(catogory)。

```null

category = serializers.PrimaryKeyRelatedField(queryset=CourseCategory.objects.all(), required=True)```

*     
    

ModelSerializer就更簡單了，直接通過映射就好了   
不過這樣只是用戶獲得的只是一個外鍵類別的id，並不能獲取到詳細的信息，如果想要獲取到具體信息，那需要嵌套serializer

```null
category = CourseCategorySerializer()```

*     
    

　　注意：上面兩種方式，外鍵都是正向取得，下面介紹怎麼反向去取，如，我們需要獲取python這個類別下，有什麼課程。   
　　首先，在課程course的model中，需要在外鍵中設置related\_name

```null
class Course(model.Model):
    category = models.ForeignKey(CourseCategory, related_name='courses')```

*     
    

```null


courses = CourseSerializer(many=True)```

*     
    

　　寫到這裏，我們的外鍵就基本講完了！還有一個小問題：我們在上面提到ModelSerializer需要解決的第二個問題中，其實還有一種情況，就是某個字段屬於指定model，但不能獲取到相關數據。   
　　假設現在是一個多級分類的課程，例如，編程語言–>python–>python入門學習課程，編程語言與python屬於類別，另外一個屬於課程，編程語言類別是python類別的一個外鍵，而且屬於同一個model，實現方法：

```null
parent_category = models.ForeignKey('self', null=True, blank=True, 
                    verbose_name='父類目別',
                    related_name='sub_cat')```

*     
    

　　現在獲取編程語言下的課程，顯然無法直接獲取到python入門學習這個課程，因爲它們兩沒有外鍵關係。SerializerMethodField( )也可以解決這個問題，只要在自定義的方法中實現相關的邏輯即可！

```null
courses = SerializerMethodField()
def get_courses(self, obj):
    all_courses = Course.objects.filter(category__parent_category_id=obj.id)
    courses_serializer = CourseSerializer(all_course, many=True, 
                    context={'request': self.context['request']})
    return courses_serializer.data```

*     
    

　　上面的例子看起來有點奇怪，因爲我們在SerializerMethodField()嵌套了serializer，就需要自己進行序列化，然後再從data就可以取出json數據。   
　　可以看到傳遞的參數是分別是：queryset，many=True多個對象，context上下文。這個context十分關鍵，如果不將request傳遞給它，在序列化的時候，圖片與文件這些Field不會再前面加上域名，也就是說，只會有/media/img…這樣的路徑！ 
 [https://webcache.googleusercontent.com/search?q=cache:UnS5QpsgZDAJ:https://www.twblogs.net/a/5b8d2e552b717718833c1810+&cd=5&hl=zh-CN&ct=clnk](https://webcache.googleusercontent.com/search?q=cache:UnS5QpsgZDAJ:https://www.twblogs.net/a/5b8d2e552b717718833c1810+&cd=5&hl=zh-CN&ct=clnk) 
 [https://webcache.googleusercontent.com/search?q=cache:UnS5QpsgZDAJ:https://www.twblogs.net/a/5b8d2e552b717718833c1810+&cd=5&hl=zh-CN&ct=clnk](https://webcache.googleusercontent.com/search?q=cache:UnS5QpsgZDAJ:https://www.twblogs.net/a/5b8d2e552b717718833c1810+&cd=5&hl=zh-CN&ct=clnk)
````
